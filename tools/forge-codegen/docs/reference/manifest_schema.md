# manifest.json Schema Reference

**Quick reference for the package contract format. For complete schema specification, see the authoritative [Package Contract](../../.claude/shared/package_contract.md).**

---

## Overview

`manifest.json` is the **source of truth** for package deployment and documentation generation. It is generated by `forge-context` during the code generation pipeline and consumed by downstream contexts.

**Purpose:**
- Canonical representation of the generated package
- Deployment contract for `deployment-context`
- Metadata source for `docgen-context`
- Debug reference for `hardware-debug-context`

**Location:** Generated in package output directory alongside VHDL files

**Format:** JSON (UTF-8 encoded, human-readable)

**Authoritative Documentation:** [Package Contract Specification](../../.claude/shared/package_contract.md)

---

## Key Concepts

### Package Contract Philosophy

The manifest.json serves as a **contract** between:
- **Producer:** `forge-context` (generates VHDL + manifest)
- **Consumers:** `deployment-context`, `docgen-context`, `hardware-debug-context`

**Design Principle:** Consumers should **never parse YAML**. They consume only manifest.json, which is the canonical output of the generation process.

**Benefits:**
- **Decoupling:** Consumers don't need to understand YAML format or code generation internals
- **Stability:** Manifest schema is more stable than internal YAML format
- **Testability:** Can test consumers with mock manifests without running full generation

---

## Quick Reference

### Key Fields

| Field | Type | Purpose | Example |
|-------|------|---------|---------|
| `app_name` | string | Application identifier | `"emfi_probe_v1"` |
| `version` | string | Semantic version | `"1.0.0"` |
| `platform` | string | Target Moku platform | `"moku_pro"` |
| `description` | string | Human-readable description | `"EMFI probe driver"` |
| `datatypes[]` | array | Signal definitions with register assignments | See below |
| `register_mappings[]` | array | Control register allocations | See below |
| `efficiency` | object | Packing efficiency metrics | See below |
| `generated_files` | array | List of generated VHDL/JSON files | See below |

### Datatypes Array

Each element represents a signal with its type and register assignment:

```json
{
  "name": "output_voltage",
  "datatype": "voltage_output_05v_s16",
  "description": "Output voltage setpoint",
  "default_value": 0,
  "units": "V",
  "cr_number": 6,
  "bit_slice": [31, 16],
  "bit_width": 16
}
```

**Key Fields:**
- `cr_number` - Which control register (6-15)
- `bit_slice` - `[MSB, LSB]` bit range within register
- `bit_width` - Number of bits for this signal

### Register Mappings Array

Summary view of control register allocations:

```json
{
  "cr_number": 6,
  "signals": ["output_voltage", "enable_output"],
  "bits_used": 17,
  "bits_available": 32,
  "utilization_percent": 53.1
}
```

### Efficiency Metrics

Packing efficiency statistics:

```json
{
  "total_bits_used": 58,
  "total_bits_allocated": 64,
  "registers_used": 2,
  "packing_efficiency_percent": 90.6,
  "registers_saved": 4
}
```

**See:** [Register Mapping Reference](register_mapping.md) for efficiency details.

---

## Complete Schema

**For the complete JSON schema specification with validation rules, field descriptions, and examples:**

ðŸ‘‰ **[Package Contract Specification](../../.claude/shared/package_contract.md)**

The package contract document includes:
- Full JSON schema with all fields
- Validation rules and constraints
- Complete manifest.json example
- control_registers.json schema
- Integration guidance for all contexts

---

## Usage by Context

### forge-context (Producer)

**Generates manifest.json** during package creation:

```python
from forge.models.package import BasicAppsRegPackage

# Load YAML
package = BasicAppsRegPackage.from_yaml('specs/my_instrument.yaml')

# Generate mapping
mappings = package.generate_mapping()

# Export manifest.json
manifest = package.to_manifest_json()
with open('output/manifest.json', 'w') as f:
    json.dump(manifest, f, indent=2)
```

**Responsibilities:**
- Validate YAML schema
- Run register mapping algorithm
- Generate VHDL files
- Produce manifest.json and control_registers.json

---

### deployment-context (Consumer)

**Reads manifest.json** for hardware deployment:

```python
import json

# Load manifest
with open('output/manifest.json') as f:
    manifest = json.load(f)

# Extract deployment info
app_name = manifest['app_name']
platform = manifest['platform']
datatypes = manifest['datatypes']

# Use CR assignments for initialization
for dt in datatypes:
    cr_num = dt['cr_number']
    bit_slice = dt['bit_slice']
    default_value = dt['default_value']
    # Configure hardware...
```

**Responsibilities:**
- Device discovery
- MCC routing configuration
- Control register initialization
- Hardware validation

**Note:** deployment-context does **not** parse YAML or generate code. It operates exclusively on manifest.json.

---

### docgen-context (Consumer)

**Reads manifest.json** to auto-generate documentation:

```python
import json

# Load manifest
with open('output/manifest.json') as f:
    manifest = json.load(f)

# Generate markdown docs
for dt in manifest['datatypes']:
    # Create signal documentation
    doc = f"## {dt['name']}\n"
    doc += f"Type: {dt['datatype']}\n"
    doc += f"Description: {dt['description']}\n"
    doc += f"Register: CR{dt['cr_number']}, bits {dt['bit_slice']}\n"
```

**Responsibilities:**
- Auto-generate markdown documentation
- Create Textual TUI applications
- Generate Python control classes
- Produce API documentation

---

### hardware-debug-context (Consumer)

**Reads manifest.json** for FSM state decoding:

```python
import json

# Load manifest
with open('output/manifest.json') as f:
    manifest = json.load(f)

# Build signal lookup table
signals = {dt['name']: dt for dt in manifest['datatypes']}

# Decode FSM state from oscilloscope
state_signal = signals['fsm_state']
cr_num = state_signal['cr_number']
bit_slice = state_signal['bit_slice']

# Extract state value from hardware
state_value = decode_voltage_to_state(voltage, bit_slice)
```

**Responsibilities:**
- FSM state decoding (voltage â†’ state number)
- Oscilloscope configuration
- Timing analysis
- Debug pattern identification

---

## Example manifest.json

For a complete example with all fields populated:

ðŸ‘‰ **[Package Contract - Example manifest.json](../../.claude/shared/package_contract.md#example-manifestjson)**

**Minimal Example:**

```json
{
  "app_name": "minimal_probe",
  "version": "1.0.0",
  "platform": "moku_go",
  "description": "Minimal 3-signal probe",
  "datatypes": [
    {
      "name": "output_voltage",
      "datatype": "voltage_output_05v_s16",
      "description": "Output voltage setpoint",
      "default_value": 0,
      "units": "V",
      "cr_number": 6,
      "bit_slice": [31, 16],
      "bit_width": 16
    },
    {
      "name": "enable_output",
      "datatype": "boolean",
      "description": "Enable output driver",
      "default_value": 0,
      "cr_number": 6,
      "bit_slice": [15, 15],
      "bit_width": 1
    }
  ],
  "register_mappings": [
    {
      "cr_number": 6,
      "signals": ["output_voltage", "enable_output"],
      "bits_used": 17,
      "bits_available": 32,
      "utilization_percent": 53.1
    }
  ],
  "efficiency": {
    "total_bits_used": 17,
    "total_bits_allocated": 32,
    "registers_used": 1,
    "packing_efficiency_percent": 53.1,
    "registers_saved": 1
  },
  "generated_files": [
    "minimal_probe_shim.vhd",
    "minimal_probe_main.vhd",
    "manifest.json",
    "control_registers.json"
  ]
}
```

---

## Validation

### Schema Validation

The manifest.json structure is validated by consumers using JSON schema:

- **Python (Pydantic):** Load into `ManifestModel` for type-safe access
- **JSON Schema:** Validate against schema before processing

**See:** [Package Contract - Schema Validation](../../.claude/shared/package_contract.md#validation-rules)

### Common Issues

**Missing fields:**
- All required fields must be present (app_name, version, platform, datatypes)
- Each datatype must include cr_number and bit_slice

**Invalid CR assignments:**
- cr_number must be 6-15 (CR4-CR5 reserved)
- bit_slice must be valid [MSB, LSB] with MSB >= LSB
- Bit ranges must not overlap within same register

**Type mismatches:**
- datatype must be valid BasicAppDataTypes enum value
- default_value must match type constraints

---

## Related Documentation

- **[Package Contract Specification](../../.claude/shared/package_contract.md)** - Authoritative schema source
- **[YAML Schema Reference](yaml_schema.md)** - Input format (what forge-context parses)
- **[Register Mapping Reference](register_mapping.md)** - How CR assignments are computed
- **[Type System Reference](type_system.md)** - Valid datatype values
- **[VHDL Generation Reference](vhdl_generation.md)** - How manifest drives code generation
- **[User Guide - Deployment](../guides/user_guide.md#deployment)** - Using manifest for hardware deployment

---

## Key Files

**Authoritative Source:**
- [`.claude/shared/package_contract.md`](../../.claude/shared/package_contract.md) - Complete schema specification

**Implementation:**
- `forge/models/package.py` - `BasicAppsRegPackage.to_manifest_json()` generator
- `forge/generator/codegen.py` - Manifest-driven VHDL generation

**Examples:**
- `docs/examples/minimal_walkthrough.md` - Minimal example with manifest
- `docs/examples/multi_channel_walkthrough.md` - Complex example with manifest

---

**Key Takeaway:** manifest.json is the **single source of truth** for package deployment. It is generated by forge-context and consumed by all downstream contexts. Consumers should never parse YAMLâ€”only manifest.json. For complete schema details, see [Package Contract Specification](../../.claude/shared/package_contract.md).

---

*Last Updated: 2025-11-03*
