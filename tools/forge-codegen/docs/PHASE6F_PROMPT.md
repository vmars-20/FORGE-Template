# Phase 6F: Validation and Debugging Documentation

**Phase:** F (Validation + Debugging)
**Status:** Ready to execute
**Prerequisite:** Phases A-E complete
**Deliverables:** 2 debugging docs + comprehensive validation

---

## Context

**Project:** moku-instrument-forge
**Working Directory:** `/Users/johnycsh/moku-instrument-forge`

**Completed Phases:**
- Phase A-B: Essential guides and technical reference âœ…
- Phase C: Examples and walkthroughs âœ…
- Phase D: Architecture documentation âœ…
- Phase E: Integration and agent references âœ…

**Existing Debugging Doc:**
- `docs/debugging/fsm_observer_pattern.md` âœ… (from EZ-EMFI migration)

**See:** `docs/PHASE6_PLAN.md` for complete context

---

## Your Task

1. **Create 2 remaining debugging docs** (hardware_validation.md, common_issues.md)
2. **Validate all documentation** (examples, snippets, links)
3. **Test all YAML examples** (validate + generate)
4. **Verify cross-references** (links work)
5. **Run through getting started tutorial** (end-to-end test)
6. **Create completion summary** (PHASE6_COMPLETE.md)

---

## Part 1: Create Debugging Documentation (2 files)

### 1.1 Create `docs/debugging/hardware_validation.md`

**Purpose:** Oscilloscope workflows for validating forge-generated instruments on real hardware

**Estimated:** ~450 lines

**Content Structure:**

```markdown
# Hardware Validation Guide

**Validating forge-generated VHDL on real Moku hardware using oscilloscopes and Python control**

---

## Table of Contents

1. [Overview](#overview)
2. [Prerequisites](#prerequisites)
3. [Validation Workflow](#validation-workflow)
4. [Control Register Verification](#control-register-verification)
5. [Output Signal Validation](#output-signal-validation)
6. [Timing Verification](#timing-verification)
7. [FSM State Debugging](#fsm-state-debugging)
8. [Common Issues](#common-issues)
9. [Platform-Specific Notes](#platform-specific-notes)
10. [MCC Routing Verification](#mcc-routing-verification)

---

## Overview

After generating VHDL with `forge-context` and deploying with `deployment-context`, validate that:
- Control registers are correctly written
- Output signals reflect register values
- Timing is correct (pulse widths, delays)
- FSM transitions work as expected

**Tools Needed:**
- Deployed Moku device (Go/Lab/Pro/Delta)
- Oscilloscope (or use Moku's built-in scope)
- Test probes
- Python control script (auto-generated by `docgen-context`)

**See Also:**
- [FSM Observer Pattern](fsm_observer_pattern.md) - Voltage-encoded FSM debugging
- [Troubleshooting - Hardware](../guides/troubleshooting.md#hardware-testing) - Common hardware issues
- [Architecture Overview](../architecture/overview.md) - System data flow

---

## Prerequisites

**Before starting hardware validation:**

1. **Package generated successfully:**
   ```bash
   uv run python -m forge.generate_package specs/my_instrument.yaml --output-dir output/my_instrument
   ```
   - âœ… `manifest.json` exists
   - âœ… `control_registers.json` exists
   - âœ… VHDL files generated

2. **Package deployed to Moku:**
   ```bash
   # (deployment-context handles this)
   # Device discovered, MCC routing configured, bitstream loaded
   ```

3. **Python control script available:**
   - Auto-generated by `docgen-context` from manifest.json
   - Or use manual register writes via Moku API

4. **Oscilloscope connected:**
   - Probes on relevant I/O pins
   - Trigger configured
   - Ground connected

---

## Validation Workflow

### Step-by-Step Validation Process

**1. Verify Default Values**
- Read control registers after deployment
- Compare to `control_registers.json`
- Ensure defaults are correctly packed

**2. Test Individual Signals**
- Write each control register field independently
- Observe corresponding output on scope
- Verify voltage levels and timing

**3. Test Multi-Signal Interactions**
- Write multiple fields in same register
- Verify no crosstalk or interference
- Check packed register behavior

**4. Validate FSM Behavior**
- Use FSM observer pattern (voltage-encoded states)
- Verify state transitions
- Check timing of state changes

---

## Control Register Verification

### Verify Control Register Writes

**Example: 3-signal minimal_probe**

From `manifest.json`:
```json
{
  "register_mappings": [
    {
      "cr_number": 6,
      "signals": ["output_voltage", "enable_output"],
      "bits_used": 17
    }
  ]
}
```

**Test with Python:**
```python
from moku import instruments

# Connect to device
instr = instruments.CustomInstrument("192.168.1.100")

# Test 1: Write output_voltage (CR6[31:16])
instr.write_control_register(6, 0x00001000)  # 4096 in upper 16 bits
# Expected: DAC output changes to corresponding voltage

# Test 2: Write enable_output (CR6[15])
instr.write_control_register(6, 0x00009000)  # Set bit 15
# Expected: Output driver enables

# Test 3: Write both (packed register)
instr.write_control_register(6, 0x20008000)  # Voltage + enable
# Expected: Both fields update simultaneously
```

**Verify with Oscilloscope:**
- Probe DAC output pin
- Confirm voltage matches expected value
- Check enable signal on digital output

**Troubleshooting:**
- If no change: Check MCC routing, verify bitstream loaded
- If wrong voltage: Check TYPE_REGISTRY conversion formula
- If intermittent: Check clock domain crossings

**See Also:**
- [Register Mapping Reference](../reference/register_mapping.md) - How signals are packed
- [Package Contract](../../.claude/shared/package_contract.md) - manifest.json schema

---

## Output Signal Validation

### DAC Output Validation

**Setup:**
```python
# Set DAC voltage to known value
voltage_raw = 16384  # 50% of Â±5V range = +2.5V
instr.write_control_register(6, voltage_raw << 16)  # Upper 16 bits
```

**Measure with Scope:**
- Expected: +2.5V (for voltage_output_05v_s16)
- Tolerance: Â±5% (hardware DAC resolution)

**Verification:**
```python
# Sweep voltage range
for voltage in [-5.0, -2.5, 0.0, 2.5, 5.0]:
    voltage_raw = int((voltage / 5.0) * 32767)
    instr.write_control_register(6, voltage_raw << 16)
    time.sleep(0.1)
    # Observe on scope: Should see stepped voltage levels
```

**Common Issues:**
- **Inverted polarity:** Check signed vs unsigned type
- **Clipped range:** Check min_value/max_value constraints
- **No output:** Check MCC routing, enable signals

---

### Digital Output Validation

**Setup:**
```python
# Set boolean flag
enable_bit = 1 << 15  # Bit 15 in CR6
instr.write_control_register(6, enable_bit)
```

**Measure with Scope:**
- Expected: Logic high (3.3V or platform-specific)
- Rise time: < 10ns (depending on platform clock)

**Verification:**
```python
# Toggle flag rapidly
for i in range(10):
    instr.write_control_register(6, 0x00008000)  # Set
    time.sleep(0.001)
    instr.write_control_register(6, 0x00000000)  # Clear
    time.sleep(0.001)
# Observe: Square wave on scope
```

---

## Timing Verification

### Pulse Width Validation

**Example: pulse_duration_ns_u16 type**

From YAML:
```yaml
- name: glitch_width
  datatype: pulse_duration_ns_u16
  default_value: 500  # 500 nanoseconds
```

**Test:**
```python
# Write pulse width (500 ns)
glitch_width_raw = 500
instr.write_control_register(7, glitch_width_raw << 16)

# Trigger pulse
instr.write_control_register(8, 0x80000000)  # Trigger bit

# Measure on scope:
# - Cursor mode: Measure pulse width
# - Expected: ~500ns (Â±platform clock period)
```

**Platform Clock Periods:**
- Moku:Go (125 MHz): 8.0 ns
- Moku:Lab (500 MHz): 2.0 ns
- Moku:Pro (1.25 GHz): 0.8 ns
- Moku:Delta (5 GHz): 0.2 ns

**Actual pulse width:** `round(500 / clock_period) * clock_period`
- Moku:Go: 500ns / 8.0ns = 62.5 â†’ 63 cycles = 504 ns âœ…

**Verification:**
```python
# Test multiple pulse widths
for width_ns in [100, 500, 1000, 5000]:
    write_pulse_width(width_ns)
    trigger_pulse()
    # Measure on scope, compare to expected (rounded to clock cycles)
```

**See Also:**
- [Type System - Platform Compatibility](../reference/type_system.md#platform-compatibility)
- [Platform Specs](../../libs/moku-models/docs/MOKU_PLATFORM_SPECIFICATIONS.md)

---

## FSM State Debugging

### Using the FSM Observer Pattern

**Technique:** Voltage-encode FSM states for oscilloscope visibility

**See:** [FSM Observer Pattern](fsm_observer_pattern.md) - Complete guide

**Quick Reference:**

1. **Add voltage-encoded state output to VHDL:**
   ```vhdl
   -- In main VHDL (user logic)
   signal fsm_state : std_logic_vector(2 downto 0);  -- 8 states max

   -- Voltage-encode for debug output
   fsm_state_voltage <= to_signed(to_integer(unsigned(fsm_state)) * 4096, 16);
   ```

2. **Route to DAC output** (via MCC)

3. **Observe on scope:**
   - State 0: 0V
   - State 1: 0.625V
   - State 2: 1.25V
   - State 3: 1.875V
   - etc.

4. **Decode state transitions:**
   - Trigger on state change
   - Measure timing between transitions
   - Verify FSM logic

**Example: Debugging "FSM stuck" issue**
- Observe voltage: constant (not transitioning)
- Check trigger signal: scope shows no trigger pulses
- Solution: Fix trigger logic or polarity

---

## Common Issues

### Issue 1: "Control register writes don't affect outputs"

**Symptoms:**
- Write CR6, DAC doesn't change
- Enable flag doesn't toggle

**Debug Steps:**
1. **Check VHDL main uses shim signals:**
   ```vhdl
   -- WRONG (ignores shim):
   output_a <= (others => '0');

   -- CORRECT (uses shim signal):
   output_a <= intensity;  -- From shim
   ```

2. **Verify bitstream reloaded:**
   ```bash
   # If VHDL changed, must re-synthesize and re-deploy
   ```

3. **Check MCC routing:**
   - See [MCC Routing Verification](#mcc-routing-verification)

4. **Verify register mapping:**
   ```bash
   cat manifest.json | grep -A5 "output_voltage"
   # Confirm cr_number and bit_slice match VHDL
   ```

**Solution:** Ensure main VHDL entity uses all shim signals, redeploy after changes.

---

### Issue 2: "Wrong voltage level on DAC"

**Symptoms:**
- Expected 2.5V, measure 0.5V
- Inverted polarity

**Debug Steps:**
1. **Check type signedness:**
   - `voltage_output_05v_s16` is signed (Â±5V)
   - `voltage_output_05v_u15` is unsigned (0-5V)
   - Verify correct type in YAML

2. **Check conversion formula:**
   ```python
   # For voltage_output_05v_s16:
   # raw = (voltage / 5.0) * 32767

   # Verify TYPE_REGISTRY formula
   from basic_app_datatypes import TYPE_REGISTRY, BasicAppDataTypes
   metadata = TYPE_REGISTRY[BasicAppDataTypes.VOLTAGE_OUTPUT_05V_S16]
   print(metadata.to_raw(2.5))  # Should be ~16384
   ```

3. **Check platform DAC range:**
   - Moku:Go/Pro/Delta: Â±5V output
   - Moku:Lab: Â±1V output (different scaling!)

**Solution:** Use correct type for platform, verify conversion formula.

**See:** [Type System Reference](../reference/type_system.md) - Type ranges

---

### Issue 3: "Timing violations in CloudCompile"

**Symptoms:**
- Synthesis fails with timing errors
- Critical paths not met

**Debug Steps:**
1. **Pipeline critical paths:**
   ```vhdl
   -- Add pipeline registers to long combinatorial paths
   signal pipeline_stage1 : voltage_output_05v_s16;

   process(Clk)
   begin
       if rising_edge(Clk) then
           pipeline_stage1 <= intensity;
           output_a <= pipeline_stage1;  -- Pipelined
       end if;
   end process;
   ```

2. **Check platform clock rate:**
   - Moku:Delta (5 GHz) has tightest timing
   - Reduce logic depth for high-speed platforms

3. **Review synthesis report:**
   - Identify critical path
   - Simplify logic or add pipelining

**Solution:** Pipeline long paths, simplify combinatorial logic.

**See:** [Platform Specs](../../libs/moku-models/docs/MOKU_PLATFORM_SPECIFICATIONS.md) - Clock rates

---

## Platform-Specific Notes

### Moku:Go (125 MHz)

**Characteristics:**
- Clock period: 8.0 ns
- ADC input: Â±25V
- DAC output: Â±5V
- 2 slots

**Timing Precision:**
- Minimum pulse width: 8 ns (1 clock cycle)
- For `pulse_duration_ns_u16(100)`: Actual = 13 cycles = 104 ns

**Validation:**
```python
# Account for 8ns granularity
expected_cycles = round(pulse_width_ns / 8.0)
actual_ns = expected_cycles * 8.0
```

---

### Moku:Lab (500 MHz)

**Characteristics:**
- Clock period: 2.0 ns
- ADC input: Â±5V
- DAC output: Â±1V (note: different from others!)
- 2 slots

**Key Difference: Â±1V DAC output**
- Use `voltage_output_05v_s16` type (platform-agnostic)
- Hardware scales to Â±1V automatically
- But scope will measure Â±1V, not Â±5V!

**Validation:**
```python
# YAML: voltage_output_05v_s16, value = 2.5V (logical)
# Expected on scope: 0.5V (2.5V * 1V/5V scaling)
```

---

### Moku:Pro (1.25 GHz)

**Characteristics:**
- Clock period: 0.8 ns
- ADC input: Â±20V
- DAC output: Â±5V
- 4 slots

**High-Speed Considerations:**
- Tight timing constraints
- Pipeline critical paths
- Use MCC carefully (routing delays matter)

---

### Moku:Delta (5 GHz)

**Characteristics:**
- Clock period: 0.2 ns
- ADC input: Â±20V
- DAC output: Â±5V
- 4 slots

**Ultra-High-Speed Considerations:**
- Very tight timing (0.2 ns!)
- Extensive pipelining required
- MCC routing critical

**Validation:**
```python
# For pulse_duration_ns_u16(100):
# 100 ns / 0.2 ns = 500 cycles (easily achievable)
```

---

## MCC Routing Verification

**MCC (Moku Connectivity Core)** routes signals between slots and I/O.

**Verify routing:**
1. Check deployment logs for MCC configuration
2. Confirm signal paths:
   - DAC outputs â†’ Physical outputs
   - ADC inputs â†’ Custom instrument
   - Cross-slot connections (if multi-slot)

**Common Routing Issues:**
- **Monitor + Output conflict:** Can't monitor and output same signal
- **Cross-slot invalid:** Some cross-slot patterns not allowed
- **Missing connection:** Signal not routed to I/O

**Debugging:**
```bash
# Check MCC routing in deployment logs
# (deployment-context prints MCC configuration)
```

**See Also:**
- [MCC Routing Patterns](../../libs/moku-models/docs/routing_patterns.md) - Common patterns
- [Troubleshooting - Deployment](../guides/troubleshooting.md#deployment-issues) - MCC errors

---

## Summary

**Validation Workflow:**
1. âœ… Verify default control register values
2. âœ… Test individual signal writes â†’ scope
3. âœ… Validate timing (pulse widths, delays)
4. âœ… Debug FSM states (voltage-encoded)
5. âœ… Check platform-specific behavior
6. âœ… Verify MCC routing

**Key Tools:**
- Oscilloscope (or Moku scope)
- Python control scripts
- manifest.json (register mappings)
- FSM observer pattern

**Common Pitfalls:**
- Forgetting to reload bitstream after VHDL changes
- Wrong type signedness (signed vs unsigned)
- Platform clock granularity (timing rounding)
- MCC routing conflicts

**Next Steps:**
- If issues found: See [Common Issues](common_issues.md)
- For FSM debugging: See [FSM Observer Pattern](fsm_observer_pattern.md)
- For deployment issues: See [Troubleshooting Guide](../guides/troubleshooting.md)

---

*Last Updated: 2025-11-03 (Phase 6F)*
*Maintained By: moku-instrument-forge team*
```

---

### 1.2 Create `docs/debugging/common_issues.md`

**Purpose:** Quick reference cookbook for debugging forge-generated instruments

**Estimated:** ~450 lines

**Content Structure:**

```markdown
# Common Issues - Debug Cookbook

**Quick reference for debugging moku-instrument-forge generated instruments**

---

## Table of Contents

1. [Overview](#overview)
2. [YAML/Generation Issues](#yamlgeneration-issues)
3. [Hardware Issues](#hardware-issues)
4. [Register Mapping Issues](#register-mapping-issues)
5. [Performance Issues](#performance-issues)
6. [Debug Techniques](#debug-techniques)

---

## Overview

This cookbook provides solutions to common issues encountered when using moku-instrument-forge.

**Issue Categories:**
- **YAML/Generation:** Validation errors, code generation failures
- **Hardware:** Deployed instruments not behaving as expected
- **Register Mapping:** Inefficient packing, unexpected allocations
- **Performance:** Timing violations, resource usage

**For comprehensive troubleshooting:** See [Troubleshooting Guide](../guides/troubleshooting.md)

---

## YAML/Generation Issues

### Issue: "Unknown datatype: 'voltage_10v_s16'"

**Error Message:**
```
ValidationError: datatype 'voltage_10v_s16' not found in BasicAppDataTypes
```

**Cause:** Type name doesn't exist in type system

**Solution:**
Check valid types:
```python
from basic_app_datatypes import BasicAppDataTypes
print(list(BasicAppDataTypes))
```

**Valid voltage output types:**
- `voltage_output_05v_s16` âœ… (Â±5V, standard)
- `voltage_10v_s16` âŒ (doesn't exist)

**See:** [Type System Reference](../reference/type_system.md#quick-reference-table) - All 23 types

---

### Issue: "default_value out of range"

**Error Message:**
```
ValidationError: default_value 40000 exceeds max (32767) for voltage_output_05v_s16
```

**Cause:** Default value exceeds type's range

**Solution:**
Check type metadata:
```python
from basic_app_datatypes import TYPE_REGISTRY, BasicAppDataTypes

metadata = TYPE_REGISTRY[BasicAppDataTypes.VOLTAGE_OUTPUT_05V_S16]
print(f"Range: {metadata.min_value} to {metadata.max_value}")
# Output: Range: -32768 to 32767
```

**Fix YAML:**
```yaml
# WRONG:
default_value: 40000  # Exceeds 32767

# CORRECT:
default_value: 32767  # Maximum for s16
```

**See:** [YAML Schema - Validation Rules](../reference/yaml_schema.md#validation-rules)

---

### Issue: "Invalid signal name 'trigger-threshold'"

**Error Message:**
```
ValidationError: Signal name 'trigger-threshold' contains invalid characters
```

**Cause:** Signal names must be valid Python/VHDL identifiers

**Rules:**
- Must start with letter (a-z, A-Z)
- Only alphanumeric and underscore (a-z, A-Z, 0-9, _)
- No hyphens, spaces, or special characters
- Not a VHDL reserved word

**Solution:**
```yaml
# WRONG:
name: trigger-threshold  # Hyphen not allowed

# CORRECT:
name: trigger_threshold  # Underscore OK
```

**See:** [YAML Schema - Signal Names](../reference/yaml_schema.md#name-string)

---

## Hardware Issues

### Issue: "Control register writes don't affect outputs"

**Symptoms:**
- Write CR6, DAC output doesn't change
- Enable boolean flag, nothing happens
- Registers write successfully (no error), but no effect

**Debug Steps:**

**1. Check VHDL main entity uses shim signals:**
```vhdl
-- In *_main.vhd entity:

-- âŒ WRONG (ignores shim):
architecture rtl of my_instrument_main is
begin
    output_a <= (others => '0');  -- Hardcoded, ignores intensity signal
end architecture;

-- âœ… CORRECT (uses shim signal):
architecture rtl of my_instrument_main is
begin
    output_a <= intensity;  -- Uses signal from shim
end architecture;
```

**2. Verify bitstream reloaded after VHDL changes:**
```bash
# If you edited VHDL, must re-synthesize and re-deploy
uv run python -m forge.generate_package specs/my_instrument.yaml
# Then redeploy with deployment-context
```

**3. Check MCC routing:**
```bash
# Review deployment logs for MCC configuration
# Ensure DAC outputs routed to physical pins
```

**4. Verify register mapping:**
```bash
cat output/manifest.json | grep -A5 "output_voltage"
# Confirm cr_number and bit_slice match what you're writing
```

**Solution:** Ensure main VHDL entity uses all shim signals. Redeploy after any VHDL changes.

**See Also:**
- [Hardware Validation Guide](hardware_validation.md#control-register-verification)
- [VHDL Generation Reference](../reference/vhdl_generation.md)

---

### Issue: "FSM stuck in one state"

**Symptoms:**
- FSM never transitions
- Triggers don't cause state changes
- System appears "frozen" in initial state

**Debug Steps:**

**1. Use FSM Observer Pattern (voltage-encoded states):**

See [FSM Observer Pattern](fsm_observer_pattern.md) for complete guide.

Quick setup:
```vhdl
-- Add to VHDL main:
fsm_state_debug <= to_signed(to_integer(unsigned(current_state)) * 4096, 16);
-- Route to DAC output via MCC
```

Observe on scope:
- Constant voltage â†’ FSM stuck
- Stepping voltages â†’ FSM transitioning

**2. Check trigger signal polarity:**
```vhdl
-- Check if trigger is active-high or active-low
when IDLE =>
    if arm_probe = '1' then  -- Active-high
        next_state <= ARMED;
    end if;

-- vs

when IDLE =>
    if arm_probe = '0' then  -- Active-low
        next_state <= ARMED;
    end if;
```

**3. Verify reset logic:**
```vhdl
-- Ensure FSM resets to IDLE
process(Clk, Reset)
begin
    if Reset = '1' then
        current_state <= IDLE;  -- Reset to initial state
    elsif rising_edge(Clk) then
        current_state <= next_state;
    end if;
end process;
```

**4. Check trigger signal actually changing:**
```python
# Toggle trigger in Python
instr.write_control_register(8, 0x80000000)  # Set trigger bit
time.sleep(0.01)
instr.write_control_register(8, 0x00000000)  # Clear trigger bit
```

**Solution:** Fix trigger polarity, add FSM observer, verify reset logic.

**See Also:**
- [FSM Observer Pattern](fsm_observer_pattern.md) - Complete debugging technique
- [Hardware Validation - FSM Debugging](hardware_validation.md#fsm-state-debugging)

---

### Issue: "Wrong voltage level on DAC output"

**Symptoms:**
- Expected +2.5V, measure +0.5V
- Inverted polarity (expected positive, measured negative)
- Voltage range doesn't match spec

**Debug Steps:**

**1. Check type signedness:**
```yaml
# YAML spec:
datatype: voltage_output_05v_s16  # Signed (Â±5V)

# vs

datatype: voltage_output_05v_u15  # Unsigned (0-5V)
```

If using unsigned type but writing signed values:
```python
# WRONG for u15 (unsigned):
write_value = -16384  # Negative not supported

# CORRECT for u15:
write_value = 16384  # Positive only
```

**2. Check platform DAC range:**
```
Moku:Go    â†’ Â±5V output âœ…
Moku:Lab   â†’ Â±1V output âš ï¸  (different!)
Moku:Pro   â†’ Â±5V output âœ…
Moku:Delta â†’ Â±5V output âœ…
```

For Moku:Lab:
- YAML: `voltage_output_05v_s16` (logical Â±5V)
- Hardware: Scaled to Â±1V automatically
- Scope measurement: Â±1V (not Â±5V!)

**3. Verify conversion formula:**
```python
from basic_app_datatypes import TYPE_REGISTRY, BasicAppDataTypes

metadata = TYPE_REGISTRY[BasicAppDataTypes.VOLTAGE_OUTPUT_05V_S16]

# For +2.5V (50% of Â±5V range):
voltage = 2.5
raw_value = int((voltage / 5.0) * 32767)
print(f"Raw value for {voltage}V: {raw_value}")  # Should be ~16384
```

**Solution:** Use correct type (signed vs unsigned), account for platform DAC range.

**See Also:**
- [Type System - Voltage Types](../reference/type_system.md#voltage-types-12)
- [Platform Compatibility](../reference/type_system.md#platform-compatibility)

---

### Issue: "Timing violations in CloudCompile"

**Symptoms:**
- Synthesis fails with timing errors
- "Critical path exceeds clock period"
- Timing constraints not met

**Debug Steps:**

**1. Pipeline critical paths:**

Add registers to break long combinatorial paths:
```vhdl
-- âŒ WRONG (long combinatorial path):
architecture rtl of my_instrument_main is
begin
    output_a <= (intensity + trigger_threshold) * scaling_factor;  -- Too much logic in one cycle
end architecture;

-- âœ… CORRECT (pipelined):
architecture rtl of my_instrument_main is
    signal stage1 : voltage_output_05v_s16;
    signal stage2 : voltage_output_05v_s16;
begin
    process(Clk)
    begin
        if rising_edge(Clk) then
            -- Pipeline stage 1: Addition
            stage1 <= intensity + trigger_threshold;

            -- Pipeline stage 2: Multiplication
            stage2 <= stage1 * scaling_factor;

            -- Output
            output_a <= stage2;
        end if;
    end process;
end architecture;
```

**2. Check platform clock rate:**
```
Moku:Go    â†’ 125 MHz  (8.0 ns period, easiest timing)
Moku:Lab   â†’ 500 MHz  (2.0 ns period)
Moku:Pro   â†’ 1.25 GHz (0.8 ns period)
Moku:Delta â†’ 5 GHz    (0.2 ns period, hardest timing!)
```

For high-speed platforms (Pro/Delta):
- Reduce logic depth
- Add more pipeline stages
- Simplify combinatorial logic

**3. Review synthesis report:**
- Identify critical path (which signals?)
- Check logic depth (how many LUTs?)
- Simplify or pipeline as needed

**Solution:** Pipeline long paths, reduce logic depth, target slower platform for prototyping.

**See Also:**
- [Platform Specs](../../libs/moku-models/docs/MOKU_PLATFORM_SPECIFICATIONS.md) - Clock rates
- [Design Decisions - Why Pipelining](../architecture/design_decisions.md)

---

## Register Mapping Issues

### Issue: "Low register efficiency (<50%)"

**Symptoms:**
```json
{
  "efficiency": {
    "packing_efficiency_percent": 34.5,  // Low!
    "registers_used": 6,
    "total_bits_used": 66,
    "total_bits_allocated": 192
  }
}
```

**Cause:** Inefficient packing strategy or suboptimal type choices

**Debug Steps:**

**1. Check signal widths (use narrowest type):**
```yaml
# âŒ WRONG (using u16 when u8 sufficient):
- name: pulse_count
  datatype: pulse_duration_ms_u16  # 0-65535 ms
  default_value: 100  # Only need 0-255!

# âœ… CORRECT (use narrower type):
- name: pulse_count
  datatype: pulse_duration_ms_u8  # 0-255 ms (8-bit, saves 8 bits)
  default_value: 100
```

**2. Use `boolean` (1-bit) not wider types:**
```yaml
# âŒ WRONG (8-bit for flag):
- name: enable
  datatype: pulse_duration_ns_u8  # Wastes 7 bits!
  default_value: 1

# âœ… CORRECT (1-bit boolean):
- name: enable
  datatype: boolean  # Only 1 bit
  default_value: 1
```

**3. Try different mapping strategy:**
```yaml
# In YAML:
mapping_strategy: type_clustering  # Default (good balance)

# Try:
mapping_strategy: best_fit  # Maximum packing density
```

**Solution:** Use narrowest types, use `boolean` for flags, try `best_fit` strategy.

**See Also:**
- [Register Mapping Algorithms](../reference/register_mapping.md) - Strategy comparison
- [Common Patterns - Register Optimization](../examples/common_patterns.md#register-optimization)

---

### Issue: "Unexpected register allocation order"

**Symptoms:**
- Expected voltage signals in CR6, but they're in CR7/CR8
- Signal order different from YAML order

**Cause:** `type_clustering` strategy groups by bit width, not YAML order

**Explanation:**

With `type_clustering` (default):
```yaml
# YAML order:
datatypes:
  - name: voltage_16bit  # 16-bit
  - name: flag           # 1-bit
  - name: time_16bit     # 16-bit
```

Generated mapping:
```
CR6: [voltage_16bit|time_16bit]  # 16-bit group
CR7: [flag]                       # 1-bit group
```

**Solution:**

If YAML order matters, use `first_fit`:
```yaml
mapping_strategy: first_fit  # Preserves YAML order
```

Or accept `type_clustering` efficiency trade-off.

**See Also:**
- [Register Mapping - Strategies](../reference/register_mapping.md#available-strategies)

---

## Performance Issues

### Issue: "Package generation slow (>10 seconds)"

**Symptoms:**
- `forge.generate_package` takes long time
- Especially with large specs (>20 signals)

**Optimization:**

**1. Use `first_fit` for development:**
```bash
# Fast packing (O(n) vs O(nÂ²) for best_fit)
uv run python -m forge.generate_package specs/my_instrument.yaml --strategy first_fit
```

**2. Cache Pydantic models:**
```python
# Reuse package object during iteration
package = BasicAppsRegPackage.from_yaml('spec.yaml')

# Make changes, re-export
manifest = package.to_manifest_json()
```

**3. Skip validation during rapid iteration:**
```bash
# Only during development! Re-enable for final generation
uv run python -m forge.generate_package spec.yaml --skip-validation
```

**See Also:**
- [Code Generation - Performance](../architecture/code_generation.md#performance-considerations)

---

## Debug Techniques

### 1. Enable Verbose Logging

```bash
uv run python -m forge.generate_package specs/my_instrument.yaml --verbose

# Or set environment variable:
export FORGE_LOG_LEVEL=DEBUG
uv run python -m forge.generate_package specs/my_instrument.yaml
```

---

### 2. Inspect Intermediate Outputs

**manifest.json:**
```bash
cat output/manifest.json | python -m json.tool
```

**control_registers.json:**
```bash
cat output/control_registers.json | python -m json.tool

# Example output:
{
  "6": "0x00FF0960",  # CR6 with packed defaults
  "7": "0xF8300820",  # CR7 with packed defaults
  "8": "0x00000000"   # CR8 (no defaults)
}
```

**Register mappings:**
```bash
cat output/manifest.json | jq '.register_mappings'
```

---

### 3. Use Python REPL for Debugging

```python
from forge.models.package import BasicAppsRegPackage

# Load package
pkg = BasicAppsRegPackage.from_yaml('specs/my_instrument.yaml')

# Inspect datatypes
for dt in pkg.datatypes:
    print(f"{dt.name}: {dt.datatype} ({dt.bit_width} bits)")

# Generate mapping
mappings = pkg.generate_mapping()
for m in mappings:
    print(f"{m.name}: CR{m.cr_number}[{m.bit_high}:{m.bit_low}]")

# Export manifest
manifest = pkg.to_manifest_json()
print(manifest)
```

---

### 4. FSM Debugging (Voltage-Encoded States)

**See:** [FSM Observer Pattern](fsm_observer_pattern.md) - Complete guide

**Quick setup:**
```vhdl
-- Add to VHDL:
fsm_state_debug <= to_signed(to_integer(unsigned(current_state)) * 4096, 16);
```

**Decode on scope:**
- 0V â†’ State 0
- 0.625V â†’ State 1
- 1.25V â†’ State 2
- etc.

---

### 5. Hardware Validation Workflow

**See:** [Hardware Validation Guide](hardware_validation.md) - Complete workflow

**Quick steps:**
1. Deploy package
2. Write control registers from Python
3. Observe outputs on oscilloscope
4. Verify timing, voltage levels, FSM transitions

---

## Summary

**Most Common Issues:**
1. âŒ VHDL main doesn't use shim signals â†’ **Use shim signals**
2. âŒ Wrong type names â†’ **Check [Type System Reference](../reference/type_system.md)**
3. âŒ FSM stuck â†’ **Use [FSM Observer Pattern](fsm_observer_pattern.md)**
4. âŒ Low register efficiency â†’ **Use narrower types, try `best_fit`**
5. âŒ Timing violations â†’ **Pipeline critical paths**

**Debug Tools:**
- Verbose logging (`--verbose`)
- Python REPL (inspect package objects)
- Oscilloscope (hardware validation)
- FSM observer (voltage-encoded states)
- manifest.json inspection

**Next Steps:**
- **For detailed hardware validation:** See [Hardware Validation Guide](hardware_validation.md)
- **For FSM debugging:** See [FSM Observer Pattern](fsm_observer_pattern.md)
- **For YAML errors:** See [Troubleshooting Guide](../guides/troubleshooting.md)

---

*Last Updated: 2025-11-03 (Phase 6F)*
*Maintained By: moku-instrument-forge team*
```

---

## Part 2: Validation Checklist

### Test 1: Validate All YAML Examples

```bash
cd /Users/johnycsh/moku-instrument-forge

# Test minimal_probe.yaml
echo "Testing minimal_probe.yaml..."
uv run python -m forge.validate_yaml docs/examples/minimal_probe.yaml
uv run python -m forge.generate_package docs/examples/minimal_probe.yaml --output-dir /tmp/test_minimal

# Verify outputs
ls /tmp/test_minimal/manifest.json
ls /tmp/test_minimal/control_registers.json
ls /tmp/test_minimal/*.vhd
cat /tmp/test_minimal/manifest.json | python -m json.tool

# Test multi_channel.yaml
echo "Testing multi_channel.yaml..."
uv run python -m forge.validate_yaml docs/examples/multi_channel.yaml
uv run python -m forge.generate_package docs/examples/multi_channel.yaml --output-dir /tmp/test_multi

# Verify outputs
ls /tmp/test_multi/manifest.json
ls /tmp/test_multi/control_registers.json
ls /tmp/test_multi/*.vhd
cat /tmp/test_multi/manifest.json | python -m json.tool
```

**Success Criteria:**
- [ ] `minimal_probe.yaml` validates without errors
- [ ] `minimal_probe.yaml` generates successfully
- [ ] `multi_channel.yaml` validates without errors
- [ ] `multi_channel.yaml` generates successfully
- [ ] Generated `manifest.json` files are valid JSON
- [ ] Generated VHDL files exist (shim + main)

---

### Test 2: Verify All Documentation Links

**Check internal links:**
```bash
# Find all markdown links
grep -r "\[.*\](.*\.md)" docs/ | grep -v PHASE6

# Check for broken relative paths
# (manual process: click each link in VS Code or GitHub preview)
```

**Check common link patterns:**
- `../guides/` - One level up
- `../../libs/` - Two levels up (to submodules)
- `../../.claude/shared/` - To shared agent files
- `#section-name` - Anchors within same file

**Success Criteria:**
- [ ] All relative links work from their file location
- [ ] All submodule links work (`libs/basic-app-datatypes/llms.txt`)
- [ ] All agent links work (`.claude/agents/*/agent.md`)
- [ ] All anchors work (`#overview`, `#type-system`, etc.)

---

### Test 3: Verify Type Count and Names

**Check all docs use correct type information:**
```bash
# Check for incorrect type count (should be 23, not 25)
grep -r "25 types" docs/
# Should return NO results (except PHASE6 files)

# Check for incorrect type names
grep -r "boolean_1" docs/
# Should return NO results (correct: "boolean")

grep -r "time_milliseconds" docs/
# Should return NO results (correct: "pulse_duration_ms")
```

**Success Criteria:**
- [ ] All docs say "23 types" (not 25)
- [ ] All docs use `boolean` (not `boolean_1`)
- [ ] All docs use `pulse_duration_*` (not `time_*`)

---

### Test 4: Run Through Getting Started Tutorial

**As a new user, follow `docs/guides/getting_started.md` step-by-step:**

```bash
# Follow tutorial exactly as written
# 1. Prerequisites
# 2. Installation
# 3. Create minimal_probe.yaml
# 4. Validate
# 5. Generate
# 6. Inspect outputs
```

**Record:**
- Any unclear steps
- Commands that don't work as written
- Missing prerequisites
- Confusing explanations

**Success Criteria:**
- [ ] Can complete tutorial without external help
- [ ] All commands work as written
- [ ] Example generates successfully
- [ ] Tutorial matches actual behavior

---

### Test 5: Documentation Completeness

**Count files created:**
```bash
# Phase A-B files
ls docs/README.md
ls docs/guides/getting_started.md
ls docs/guides/user_guide.md
ls docs/guides/troubleshooting.md
ls docs/architecture/submodule_integration.md

# Phase B files (6 reference docs)
ls docs/reference/*.md | wc -l  # Should be 6

# Phase C files (5 example files)
ls docs/examples/*.{yaml,md} | wc -l  # Should be 5

# Phase D files (4 architecture docs)
ls docs/architecture/*.md | wc -l  # Should be 5 (including submodule_integration.md)

# Phase F files (3 debugging docs)
ls docs/debugging/*.md | wc -l  # Should be 3
```

**Success Criteria:**
- [ ] All 28+ documentation files created
- [ ] All Phases A-F complete
- [ ] Agent files updated (all 5)
- [ ] llms.txt updated

---

## Part 3: Final Deliverables

### Create `docs/PHASE6_COMPLETE.md`

**After all validation passes:**

```markdown
# Phase 6 Documentation - Complete âœ…

**Completion Date:** 2025-11-03
**Total Deliverables:** 28 documentation files + 7 updates

---

## Phases Summary

### Phase A: Structure + Essential Guides âœ…
- `docs/README.md` - Navigation hub
- `docs/guides/getting_started.md` - 30-min tutorial
- `docs/guides/user_guide.md` - Comprehensive guide
- `docs/guides/troubleshooting.md` - Debug reference
- `docs/architecture/submodule_integration.md` - Submodule strategy
- Directory structure created

### Phase B: Technical Reference âœ…
- `docs/reference/type_system.md` - 23 types catalog
- `docs/reference/yaml_schema.md` - Complete YAML spec
- `docs/reference/register_mapping.md` - Packing algorithms
- `docs/reference/manifest_schema.md` - Package contract reference
- `docs/reference/vhdl_generation.md` - Code generation pipeline
- `docs/reference/python_api.md` - Python API reference

### Phase C: Examples and Walkthroughs âœ…
- `docs/examples/minimal_probe.yaml` - 3-signal example
- `docs/examples/minimal_walkthrough.md` - Deep dive
- `docs/examples/multi_channel.yaml` - 6-signal example
- `docs/examples/multi_channel_walkthrough.md` - Advanced guide
- `docs/examples/common_patterns.md` - Reusable patterns

### Phase D: Architecture Documentation âœ…
- `docs/architecture/overview.md` - System architecture
- `docs/architecture/code_generation.md` - Pipeline internals
- `docs/architecture/agent_system.md` - 5-agent boundaries
- `docs/architecture/design_decisions.md` - Design rationale

### Phase E: Integration and Agent References âœ…
- `llms.txt` - Updated with comprehensive type system section
- `.claude/agents/forge-context/agent.md` - Added doc references
- `.claude/agents/deployment-context/agent.md` - Added doc references
- `.claude/agents/docgen-context/agent.md` - Added doc references
- `.claude/agents/hardware-debug-context/agent.md` - Added doc references
- `.claude/agents/workflow-coordinator/agent.md` - Added doc references
- `.claude/shared/type_system_quick_ref.md` - NEW quick reference

### Phase F: Validation and Debugging âœ…
- `docs/debugging/hardware_validation.md` - Oscilloscope workflows
- `docs/debugging/common_issues.md` - Debug cookbook
- `docs/debugging/fsm_observer_pattern.md` - FSM debugging (from EZ-EMFI)
- All validation tests passed
- All examples verified

---

## Success Metrics

### Documentation Coverage âœ…
- âœ… All 23 types documented with correct names
- âœ… Complete YAML schema specification
- âœ… Getting started tutorial tested (30-min workflow)
- âœ… User guide comprehensive
- âœ… Troubleshooting guide complete
- âœ… Architecture documentation thorough
- âœ… Submodule integration documented
- âœ… Agent system documented

### Quality Standards âœ…
- âœ… All examples tested (YAML validates and generates)
- âœ… All cross-references verified
- âœ… Code examples accurate
- âœ… Links verified
- âœ… No duplication of submodule content
- âœ… Single source of truth maintained

### Accessibility âœ…
- âœ… New users can follow getting_started.md
- âœ… Technical reference complete for advanced users
- âœ… Examples cover common patterns
- âœ… Tutorial-first approach
- âœ… Hardware debugging guides comprehensive

### Integration âœ…
- âœ… All 5 agents reference new documentation
- âœ… llms.txt enhanced with type system
- âœ… Submodule docs properly linked
- âœ… Agent boundaries clear
- âœ… Package contract documented

---

## Key Achievements

**Documentation Philosophy:**
- âœ… Link, don't duplicate (single source of truth)
- âœ… Tutorial-first approach (working code before theory)
- âœ… Comprehensive troubleshooting (all error categories)
- âœ… Architecture transparency (design decisions documented)

**Type System:**
- âœ… 23 types correctly documented
- âœ… Correct naming (`boolean`, `pulse_duration_*`)
- âœ… Platform compatibility explained
- âœ… Quick reference for agents created

**Examples:**
- âœ… minimal_probe (51.6% efficiency)
- âœ… multi_channel (90.6% efficiency)
- âœ… All examples tested and working
- âœ… Common patterns documented

**Agent Integration:**
- âœ… All 5 agents have documentation references
- âœ… Clear scope boundaries
- âœ… Workflow coordination documented
- âœ… Package contract as source of truth

---

## What's Next

Documentation is complete! Users can now:
- âœ… Follow 30-min tutorial â†’ deployed package
- âœ… Understand type system (23 types with correct names)
- âœ… Use register mapping (50-75% space savings)
- âœ… Debug hardware issues with oscilloscope
- âœ… Understand agent architecture (5 specialized agents)
- âœ… Extend forge with new features

**For Future Enhancements:**
- Add more examples (advanced patterns, multi-slot designs)
- Create video tutorials
- Add interactive documentation (Textual TUI)
- Expand hardware validation guides per platform

---

**Phase 6 Documentation Project: COMPLETE âœ…**

*Completed: 2025-11-03*
*Total Time: 6 days (Phases A-F)*
*Total Files: 28 documentation files + 7 updates*
*Total Lines: ~12,000 lines of documentation*
```

---

## Success Criteria

**All checks must pass:**

- [ ] 2 debugging docs created (hardware_validation.md, common_issues.md)
- [ ] All YAML examples validate and generate successfully
- [ ] All cross-references work (links verified)
- [ ] Getting started tutorial verified (end-to-end test)
- [ ] Documentation complete (28 files + 7 updates)
- [ ] Quality standards met (no duplication, accurate examples)
- [ ] Type information correct (23 types, correct names)
- [ ] `PHASE6_COMPLETE.md` created

---

## Final Commit Sequence

```bash
# 1. Commit debugging docs
git add docs/debugging/hardware_validation.md docs/debugging/common_issues.md
git commit -m "$(cat <<'EOF'
docs: Complete Phase 6F - Hardware validation and debug cookbook

Phase F deliverables (2 files):
- docs/debugging/hardware_validation.md - Oscilloscope validation workflows
- docs/debugging/common_issues.md - Quick reference debug cookbook

Key content:
âœ… Control register verification techniques
âœ… DAC/digital output validation
âœ… Timing verification (pulse widths, FSM transitions)
âœ… Platform-specific debugging (Go/Lab/Pro/Delta)
âœ… MCC routing verification
âœ… Common issues with solutions
âœ… Debug techniques (verbose logging, REPL, FSM observer)

Related:
- Leverages FSM Observer Pattern from EZ-EMFI migration
- References Phase A-D documentation
- Completes debugging documentation trio

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

# 2. Commit completion summary
git add docs/PHASE6_COMPLETE.md
git commit -m "$(cat <<'EOF'
docs: Phase 6 complete - All documentation delivered

Phase 6 Summary:
- 28 documentation files created
- 7 agent/config files updated
- All validation tests passed
- All examples verified

Deliverables:
âœ… Phase A: Structure + Essential Guides (6 files)
âœ… Phase B: Technical Reference (6 files)
âœ… Phase C: Examples (5 files)
âœ… Phase D: Architecture (4 files)
âœ… Phase E: Integration (7 updates)
âœ… Phase F: Debugging (3 files) + Validation

Key Metrics:
- 23 types documented (correct names, correct count)
- 30-min tutorial tested and working
- 50-75% register packing efficiency demonstrated
- 5-agent architecture documented
- Hardware debugging guides comprehensive

What Users Can Do Now:
- Follow getting_started.md â†’ deployed package (30 min)
- Understand type system (23 types)
- Debug hardware with oscilloscope
- Extend forge with confidence

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>
EOF
)"

# 3. Update plan to mark Phase F complete
git add docs/PHASE6_PLAN.md
git commit -m "docs: Update Phase 6 plan - All phases complete âœ…"
```

---

**Ready to begin Phase 6F - Final validation and completion!**

**Key Enhancements from Original PHASE6F_PROMPT.md:**
1. âœ… Correct type count: 23 (not 25)
2. âœ… Correct type names: `boolean`, `pulse_duration_*`
3. âœ… Comprehensive debugging doc templates (hardware_validation.md, common_issues.md)
4. âœ… Platform-specific validation guidance
5. âœ… FSM debugging integration
6. âœ… MCC routing verification
7. âœ… Concrete validation steps
8. âœ… References to Phase A-E documentation
