#!/usr/bin/env python3
"""
Generate frozen VHDL type utility packages for BasicAppDataTypes.

This script generates VHDL packages that provide type definitions and conversion
functions for BasicAppDataTypes. These packages are generated ONCE, committed to
the repository, and NEVER regenerated to ensure stability.

Version: 1.0.0 (FROZEN)

Generated files:
    - forge/vhdl/basic_app_types_pkg.vhd
    - forge/vhdl/basic_app_voltage_pkg.vhd
    - forge/vhdl/basic_app_time_pkg.vhd

Usage:
    python tools/generate_type_utilities.py

Note: Run this script ONCE, commit the generated files, and freeze them.
"""

import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

from forge_codegen.basic_serialized_datatypes import TYPE_REGISTRY, BasicAppDataTypes


def generate_types_package() -> str:
    """Generate the core types package with constants and type definitions."""

    header = """------------------------------------------------------------------------------
-- basic_app_types_pkg.vhd
--
-- Core types and constants for BasicAppDataTypes
--
-- Generated by: tools/generate_type_utilities.py
-- Version: 1.0.0 (FROZEN - DO NOT REGENERATE)
-- Date: 2025-11-03
--
-- This package is FROZEN and should NEVER be regenerated. Apps import this
-- via VHDL libraries to ensure stability across projects.
------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

package basic_app_types_pkg is

    ------------------------------------------------------------------------------
    -- Type Categories
    ------------------------------------------------------------------------------

    -- Boolean types: Direct mapping to std_logic
    -- Voltage types: Fixed-point representations of analog voltages
    -- Time types: Durations requiring clock frequency for conversion
    -- Count types: Integer counts with configurable ranges

    ------------------------------------------------------------------------------
    -- Constants
    ------------------------------------------------------------------------------

    -- Version identifier
    constant BAD_TYPES_VERSION : string := "1.0.0";

    ------------------------------------------------------------------------------
    -- Utility Functions
    ------------------------------------------------------------------------------

    -- Convert boolean to std_logic
    function bool_to_sl(b : boolean) return std_logic;

    -- Convert std_logic to boolean
    function sl_to_bool(sl : std_logic) return boolean;

end package basic_app_types_pkg;

package body basic_app_types_pkg is

    function bool_to_sl(b : boolean) return std_logic is
    begin
        if b then
            return '1';
        else
            return '0';
        end if;
    end function;

    function sl_to_bool(sl : std_logic) return boolean is
    begin
        return sl = '1';
    end function;

end package body basic_app_types_pkg;
"""

    return header


def generate_voltage_package() -> str:
    """Generate voltage conversion package with all voltage type utilities."""

    # Get all voltage types from registry (types with unit='mV')
    voltage_types = [
        (name, info) for name, info in TYPE_REGISTRY.items()
        if info.unit == 'mV'
    ]

    header = """------------------------------------------------------------------------------
-- basic_app_voltage_pkg.vhd
--
-- Voltage type conversion utilities for BasicAppDataTypes
--
-- Generated by: tools/generate_type_utilities.py
-- Version: 1.0.0 (FROZEN - DO NOT REGENERATE)
-- Date: 2025-11-03
--
-- This package provides conversion functions between raw register values and
-- VHDL types for all voltage-based BasicAppDataTypes.
--
-- Voltage ranges and scaling factors are embedded in function names to ensure
-- type safety and prevent unit confusion.
------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

library WORK;
use WORK.basic_app_types_pkg.ALL;

package basic_app_voltage_pkg is

    ------------------------------------------------------------------------------
    -- Voltage Type Conversions
    ------------------------------------------------------------------------------
"""

    functions = []

    for type_enum, type_info in sorted(voltage_types):
        # Get string name from enum
        type_name = type_enum.name.lower()

        # Extract voltage range and bits from type name
        # Format: voltage_{input|output}_{range}_{bits}
        # Example: voltage_output_05v_s16
        parts = type_name.split('_')
        direction = parts[1]  # input or output
        range_str = parts[2]  # e.g., 05v, 1v, 10v, 50v
        bits_str = parts[3]   # e.g., s16, u16

        signed = bits_str.startswith('s')
        bits = int(bits_str[1:])

        # Convert range string to voltage (05v -> 0.5, 1v -> 1.0, etc.)
        if range_str.startswith('0'):
            voltage = float(range_str[1:].rstrip('v')) / 10.0
        else:
            voltage = float(range_str.rstrip('v'))

        vhdl_type = "signed" if signed else "unsigned"

        # Generate from_raw function (register -> VHDL type)
        functions.append(f"""
    -- Convert raw register bits to {type_name}
    -- Range: ±{voltage}V, Bits: {bits}, Type: {vhdl_type}
    function {type_name}_from_raw(
        raw : std_logic_vector({bits-1} downto 0)
    ) return {vhdl_type};
""")

        # Generate to_raw function (VHDL type -> register)
        functions.append(f"""
    -- Convert {type_name} to raw register bits
    function {type_name}_to_raw(
        value : {vhdl_type}({bits-1} downto 0)
    ) return std_logic_vector;
""")

    body_header = """
end package basic_app_voltage_pkg;

package body basic_app_voltage_pkg is

"""

    body_functions = []

    for type_enum, type_info in sorted(voltage_types):
        type_name = type_enum.name.lower()
        parts = type_name.split('_')
        bits_str = parts[3]
        signed = bits_str.startswith('s')
        bits = int(bits_str[1:])
        vhdl_type = "signed" if signed else "unsigned"

        # from_raw implementation
        body_functions.append(f"""
    function {type_name}_from_raw(
        raw : std_logic_vector({bits-1} downto 0)
    ) return {vhdl_type} is
    begin
        return {vhdl_type}(raw);
    end function;
""")

        # to_raw implementation
        body_functions.append(f"""
    function {type_name}_to_raw(
        value : {vhdl_type}({bits-1} downto 0)
    ) return std_logic_vector is
    begin
        return std_logic_vector(value);
    end function;
""")

    footer = """
end package body basic_app_voltage_pkg;
"""

    return header + ''.join(functions) + body_header + ''.join(body_functions) + footer


def generate_time_package() -> str:
    """Generate time conversion package with clock-aware utilities."""

    # Get all time types from registry (types with unit in ns/us/ms/s)
    time_types = [
        (name, info) for name, info in TYPE_REGISTRY.items()
        if info.unit in ('ns', 'us', 'ms', 's')
    ]

    header = """------------------------------------------------------------------------------
-- basic_app_time_pkg.vhd
--
-- Time type conversion utilities for BasicAppDataTypes
--
-- Generated by: tools/generate_type_utilities.py
-- Version: 1.0.0 (FROZEN - DO NOT REGENERATE)
-- Date: 2025-11-03
--
-- This package provides conversion functions between time durations and clock
-- cycles for all time-based BasicAppDataTypes.
--
-- All functions are clock-frequency aware and accept CLK_FREQ_HZ as a parameter.
------------------------------------------------------------------------------

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

library WORK;
use WORK.basic_app_types_pkg.ALL;

package basic_app_time_pkg is

    ------------------------------------------------------------------------------
    -- Time Unit Conversions
    ------------------------------------------------------------------------------

    -- Convert nanoseconds to clock cycles
    function ns_to_cycles(
        ns_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert clock cycles to nanoseconds
    function cycles_to_ns(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert microseconds to clock cycles
    function us_to_cycles(
        us_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert clock cycles to microseconds
    function cycles_to_us(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert milliseconds to clock cycles
    function ms_to_cycles(
        ms_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert clock cycles to milliseconds
    function cycles_to_ms(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert seconds to clock cycles
    function s_to_cycles(
        s_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

    -- Convert clock cycles to seconds
    function cycles_to_s(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned;

end package basic_app_time_pkg;

package body basic_app_time_pkg is

    function ns_to_cycles(
        ns_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable cycles_per_ns : real;
        variable result : unsigned(ns_value'length-1 downto 0);
    begin
        cycles_per_ns := real(CLK_FREQ_HZ) / 1.0e9;
        result := to_unsigned(integer(real(to_integer(ns_value)) * cycles_per_ns), ns_value'length);
        return result;
    end function;

    function cycles_to_ns(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable ns_per_cycle : real;
        variable result : unsigned(cycles'length-1 downto 0);
    begin
        ns_per_cycle := 1.0e9 / real(CLK_FREQ_HZ);
        result := to_unsigned(integer(real(to_integer(cycles)) * ns_per_cycle), cycles'length);
        return result;
    end function;

    function us_to_cycles(
        us_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable cycles_per_us : real;
        variable result : unsigned(us_value'length-1 downto 0);
    begin
        cycles_per_us := real(CLK_FREQ_HZ) / 1.0e6;
        result := to_unsigned(integer(real(to_integer(us_value)) * cycles_per_us), us_value'length);
        return result;
    end function;

    function cycles_to_us(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable us_per_cycle : real;
        variable result : unsigned(cycles'length-1 downto 0);
    begin
        us_per_cycle := 1.0e6 / real(CLK_FREQ_HZ);
        result := to_unsigned(integer(real(to_integer(cycles)) * us_per_cycle), cycles'length);
        return result;
    end function;

    function ms_to_cycles(
        ms_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable cycles_per_ms : real;
        variable result : unsigned(ms_value'length-1 downto 0);
    begin
        cycles_per_ms := real(CLK_FREQ_HZ) / 1.0e3;
        result := to_unsigned(integer(real(to_integer(ms_value)) * cycles_per_ms), ms_value'length);
        return result;
    end function;

    function cycles_to_ms(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable ms_per_cycle : real;
        variable result : unsigned(cycles'length-1 downto 0);
    begin
        ms_per_cycle := 1.0e3 / real(CLK_FREQ_HZ);
        result := to_unsigned(integer(real(to_integer(cycles)) * ms_per_cycle), cycles'length);
        return result;
    end function;

    function s_to_cycles(
        s_value : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable result : unsigned(s_value'length-1 downto 0);
    begin
        result := to_unsigned(to_integer(s_value) * CLK_FREQ_HZ, s_value'length);
        return result;
    end function;

    function cycles_to_s(
        cycles : unsigned;
        CLK_FREQ_HZ : integer
    ) return unsigned is
        variable result : unsigned(cycles'length-1 downto 0);
    begin
        result := to_unsigned(to_integer(cycles) / CLK_FREQ_HZ, cycles'length);
        return result;
    end function;

end package body basic_app_time_pkg;
"""

    return header


def main():
    """Generate all VHDL type utility packages."""

    # Define output directory
    output_dir = project_root / "shared" / "custom_inst" / "vhdl"
    output_dir.mkdir(parents=True, exist_ok=True)

    print("=" * 80)
    print("Generating VHDL Type Utility Packages")
    print("Version: 1.0.0 (FROZEN)")
    print("=" * 80)

    # Generate core types package
    print("\n[1/3] Generating basic_app_types_pkg.vhd...")
    types_pkg = generate_types_package()
    types_path = output_dir / "basic_app_types_pkg.vhd"
    types_path.write_text(types_pkg)
    print(f"       Written: {types_path}")
    print(f"       Size: {len(types_pkg)} bytes")

    # Generate voltage package
    print("\n[2/3] Generating basic_app_voltage_pkg.vhd...")
    voltage_pkg = generate_voltage_package()
    voltage_path = output_dir / "basic_app_voltage_pkg.vhd"
    voltage_path.write_text(voltage_pkg)
    print(f"       Written: {voltage_path}")
    print(f"       Size: {len(voltage_pkg)} bytes")
    voltage_count = len([t for t in TYPE_REGISTRY if TYPE_REGISTRY[t].unit == 'mV'])
    print(f"       Voltage types: {voltage_count}")

    # Generate time package
    print("\n[3/3] Generating basic_app_time_pkg.vhd...")
    time_pkg = generate_time_package()
    time_path = output_dir / "basic_app_time_pkg.vhd"
    time_path.write_text(time_pkg)
    print(f"       Written: {time_path}")
    print(f"       Size: {len(time_pkg)} bytes")

    print("\n" + "=" * 80)
    print("✅ Generation Complete")
    print("=" * 80)
    print("\nNext steps:")
    print("1. Review generated VHDL files")
    print("2. Commit to repository:")
    print("   git add forge/vhdl/basic_app_*.vhd")
    print("   git commit -m 'feat(BAD/P4): Add frozen VHDL type utilities v1.0.0'")
    print("3. FREEZE these files (never regenerate)")
    print("\nThese packages should be imported in custom_inst applications via:")
    print("   library WORK;")
    print("   use WORK.basic_app_types_pkg.all;")
    print("   use WORK.basic_app_voltage_pkg.all;  -- If using voltage types")
    print("   use WORK.basic_app_time_pkg.all;     -- If using time types")


if __name__ == "__main__":
    main()
